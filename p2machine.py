# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f5xzJ3Hk1ynPOEa2FcjwFb4FP5_QxaZW
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from collections import Counter

df = pd.read_csv(r'/content/BankNote_Authentication.csv')


def euclidean_distance(x1, x2):
    distance = np.sqrt(np.sum((x1 - x2) ** 2))
    return distance


class KNN:
    def __init__(self, k=3):
        self.k = k

    def fit(self, X, y):
        self.X_train = X
        self.y_train = y

    def predict(self, X):
        predictions = [self._predict(x) for x in X]
        return predictions

    def _predict(self, x):
        # Compute the distance
        distances = [euclidean_distance(x, x_train) for x_train in self.X_train]
        zeros = 0
        ones = 0
        # Take indices of shortest distances
        k_indices = np.argsort(distances)
        # Check the distances of k elements
        for i in range(self.k):
            if (self.y_train[k_indices[i]] == 0):
                zeros = zeros + 1
            else:
                ones = ones + 1

        if (zeros > ones):  # zeros are more than ones in the k elements we classify it as 0
            ans = 0
        elif (ones > zeros):  # ones are more than zeros in the k elements we classify it as 1
            ans = 1
        else:  # Tie case we take the first element value of the k elements
            ans = self.y_train[k_indices[i]]

        return ans


# Splitting and reshaping
X_train, X_test, y_train, y_test = train_test_split(df.drop(columns=['class']), df['class'],
                                                    test_size=0.3)  # shuffle = true
X_train = np.array(X_train).reshape(-1, 4)
X_test = np.array(X_test).reshape(-1, 4)
y_train = np.array(y_train)
y_test = np.array(y_test)

# Normalization
X_train = (X_train - X_train.mean()) / X_train.std()
X_test = (X_test - X_test.mean()) / X_test.std()

k1 = 5
count1 = 0
instance = KNN(k1)
instance.fit(X_train, y_train)
predictions1 = instance.predict(X_test)
np.array(predictions1)
for i in range(len(predictions1)):
    if (predictions1[i] == y_test[i]):
        count1 = count1 + 1

acc = count1 / len(y_test)
print("k value :" + str(k1))
print("Number of correctly classified instances : " + str(count1) + " Total number of instances : " + str(len(y_test)))
print("Accuracy :" + str(acc))
print("/////////////////////////////////////////////////////////////")

k2 = 150
count2 = 0
instance = KNN(k2)
instance.fit(X_train, y_train)
predictions2 = instance.predict(X_test)
np.array(predictions2)
for i in range(len(predictions2)):
    if (predictions2[i] == y_test[i]):
        count2 = count2 + 1

acc2 = count2 / len(y_test)
print("k value :" + str(k2))
print("Number of correctly classified instances : " + str(count2) + " Total number of instances : " + str(len(y_test)))
print("Accuracy :" + str(acc2))
print("/////////////////////////////////////////////////////////////")

k3 = 300
count3 = 0
instance = KNN(k3)
instance.fit(X_train, y_train)
predictions3 = instance.predict(X_test)
np.array(predictions3)
for i in range(len(predictions3)):
    if (predictions3[i] == y_test[i]):
        count3 = count3 + 1

acc3 = count3 / len(y_test)
print("k value :" + str(k3))
print("Number of correctly classified instances : " + str(count3) + " Total number of instances : " + str(len(y_test)))
print("Accuracy :" + str(acc3))
print("/////////////////////////////////////////////////////////////")